#Use default rounding for binning, alternative (false) ceil for > x.7, else floor
#Three modes are available: default arithmetic rounding (RINT), alternatively ceil for > x.7, else floor (ROPINT) and
#simple floor rounding (RFLOORINT)
MaltcmsTools.binMZ.mode = RINT
#Use the average intensity of overlapping bins as new value, or use total intensity
ArrayTools.createDenseArray.average_bins = false 
#value of intensities without mass-to-charge value
intensity.missing.value = 0

#Run NormalizationFilter with normalization function evaluated over 
#all passed in arrays 
maltcms.commands.filter.array.normalize_global = false
#Divisor of normalization expression for x=>x/normalization_command
maltcms.commands.filter.array.normalization_command = Max-Min

dense.arrays = maltcms.commands.fragments.DenseArrayProducer
#a value of 1.0d will treat masses with integer accuracy
#a value <1.0d will subsample the masses, so e.g. 0.5 means 
#a value >1.0d will supersample the masses, so that you get a higher precision and better distinction of masses
#within the bins
dense_arrays.massBinResolution = 1.0d
#mask specific masses (removal from scans as well as tic), if left empty, no masses are masked
maltcms.commands.fragments.DenseArrayProducer.maskMasses =
#Whether the masses being masked should be inverted, so that only those masses 
#given in maskMasses are evaluated
maltcms.commands.fragments.DenseArrayProducer.invertMaskedMasses = false 
#apply normalization to intensities of every scan when producing dense arrays
#such that the length of intensity vectors = 1 after normalization
maltcms.commands.fragments.DenseArrayProducer.normalizeScans = true
maltcms.commands.fragments.DenseArrayProducer.min_mass = 50.0
maltcms.commands.fragments.DenseArrayProducer.max_mass = 550.0 

#Set the peak threshold as percentage of maximum intensity in chromatogram, 0<peak_threshold<=1
maltcms.commands.fragments.TICPeakFinder.peak_threshold = 0.01
maltcms.commands.fragments.TICPeakFinder.filter_window = 10
maltcms.commands.fragments.TICPeakFinder.mass_epsilon = 0.05
maltcms.commands.fragments.TICPeakFinder.saveGraphics = false
#If true: If a peak candidate is a bidirectional best hit to exactly one Peak in 
#all other files, and all pairs of these peaks are bidirectional best hits
#of each other, keep the peak.
#If false: Simple bidirectional best hit is enough for peak assignment 
maltcms.commands.fragments.assignment.PeakCliqueAssignment.keepOnlyBiDiBestHitsForAll = true
#Size of the minimal number of peaks forming a clique, 2 is minimum, any number
#greater than 2 will return only cliques with peaks identified in exactly n chro#matograms, -1 will return cliques with peaks identified in all chromatograms
maltcms.commands.fragments.assignment.PeakCliqueAssignment.minCliqueSize = 2
#Similarity or distance function to use between peaks
maltcms.commands.fragments.assignment.PeakCliqueAssignment.costFunction = maltcms.commands.distances.ArrayTimePenalizedDot
maltcms.commands.fragments.assignment.PeakCliqueAssignment.useUserSuppliedAnchors = false
#there exist some vendor specific variants of netcdf where mass_range_min
#does not contain the real minimum mass, so set this to false if you are sure
#that this is not the case for your data
maltcms.tools.MaltcmsTools.ignoreMinMaxMassArrays = true

maltcms.commands.scanners.ArrayStatsScanner.ignorePositiveInfinity = true
maltcms.commands.scanners.ArrayStatsScanner.ignoreNegativeInfinity = true
