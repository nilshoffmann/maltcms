#scan alignment based on local distances of mass-to-charge and intensity
alignment.algorithm = maltcms.commands.distances.dtw.MZIDynamicTimeWarp
alignment.algorithm.compressionweight=1.0
alignment.algorithm.expansionweight=1.0
alignment.algorithm.diagonalweight=1.0
#class to calculate DP recursion
alignment.cumulative.distance = maltcms.commands.distances.CumulativeDistance
#possible values are (all prefixed with maltcms.commands.distances)
#ArrayLp Euclidean Distance
#ArrayCorr Linear Correlation Similarity
#ArrayCos Cosine Similarity
#ArrayDot Dot Product Similarity
#ArrayHamming Hamming Distance
#ArrayDotLp Weighting of Euclidean Distance by value of Cosine
alignment.algorithm.distance = maltcms.commands.distances.ArrayCos
#applies a Sakoe-Chiba Band constraint around the main diagonal of the alignment
#excludes calculation of elements outside of band |i-j|<=w 
#where w:=max(length(x),length(y))*windowsize
#Note: this does not guarantee an optimal alignment if set below 1.0!
alignment.algorithm.windowsize = 1.0
alignment.algorithm.globalGapPenalty = 0.0
#should the cumulative distance matrix, upon which the path is calculated, be saved?
alignment.save.cumulative.distance.matrix = false 
#should the pairwise distance matrix, upon which the cumulative distance is calculated, be saved?
alignment.save.pairwise.distance.matrix = false
#should we save an image of the matrix layout? can help to spot problems
alignment.saveLayoutImage = false

alignment.normalizeAlignmentValueByMapWeights = true

#if set to 0, use all present mass channels for alignment, if set >0, use only the top k
#mass channels which have the highest variance
maltcms.commands.distances.dtw.MZIDynamicTimeWarp.numberOfEICsToSelect = 0
#whether to use sparse arrays or dense arrays, this is a tradeoff low mem vs high mem, low speed vs high speed
maltcms.commands.distances.dtw.MZIDynamicTimeWarp.useSparseArrays = false
alignment.precalculatePairwiseDistances = false
#If set to true will apply the band constraint (if >0 && <1) to the complete
#matrix. Otherwise applies the band to each partition as define by anchors
alignment.globalBand = true

maltcms.datastructures.fragments.PairwiseAlignment.normalizeAlignmentValueByMapWeights = true
#Elements around a given anchor which should be considered for alignment
alignment.anchors.neighborhood = 0

#whether CenterStar should ignore the optimum and simply align to the first chromatogram
maltcms.commands.fragments.alignment.CenterStarAlignment.alignToFirst = false

#minimum number of consecutive scans between two anchors
#avoids anchors following each other directly, separated by only one scan
maltcms.datastructures.alignment.DefaultPairSet.minScansBetweenAnchors = 1

#Window in which to determine maximum/minimum value of local similarity
#used to retain aligned peaks and remove everything in between
maltcms.tools.PathTools.window = 5

#settings for local similarities/distances
#Note: The weights influence the smoothness of the warping obtained
maltcms.commands.distances.ArrayCorr.compression_weight = 1.0
maltcms.commands.distances.ArrayCorr.expansion_weight = 1.0
maltcms.commands.distances.ArrayCorr.diagonal_weight = 2.25

maltcms.commands.distances.ArrayCos.compression_weight = 1.0
maltcms.commands.distances.ArrayCos.expansion_weight = 1.0
maltcms.commands.distances.ArrayCos.diagonal_weight = 2.25

maltcms.commands.distances.ArrayDot.compression_weight = 1.0
maltcms.commands.distances.ArrayDot.expansion_weight = 1.0
maltcms.commands.distances.ArrayDot.diagonal_weight = 2.25

maltcms.commands.distances.ArrayDotLp.compression_weight = 1.0
maltcms.commands.distances.ArrayDotLp.expansion_weight = 1.0
maltcms.commands.distances.ArrayDotLp.diagonal_weight = 1.0

maltcms.commands.distances.ArrayLp.compression_weight = 1.0
maltcms.commands.distances.ArrayLp.expansion_weight = 1.0
maltcms.commands.distances.ArrayLp.diagonal_weight = 1.0
maltcms.commands.distances.ArrayLp.normalizeByLength = false

maltcms.commands.distances.ArrayTimePenalizedDot.compression_weight = 1.0
maltcms.commands.distances.ArrayTimePenalizedDot.expansion_weight = 1.0
maltcms.commands.distances.ArrayTimePenalizedDot.diagonal_weight = 1.0
#Variance allowed for normally distributed RT difference penalty
maltcms.commands.distances.ArrayTimePenalizedDot.rtTolerance = 50.0
#epsilon below which (<=) the cos/dot product calculation will not be performed
maltcms.commands.distances.ArrayTimePenalizedDot.rtEpsilon = 0.5

maltcms.commands.distances.ArrayHamming.expansion_weight = 1.0
maltcms.commands.distances.ArrayHamming.compression_weight = 1.0
maltcms.commands.distances.ArrayHamming.diagonal_weight = 1.0
